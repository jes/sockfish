#!/usr/bin/perl

use strict;
use warnings;

use Time::HiRes qw(usleep);
use Chess::Rep;
use Try::Tiny;
use IO::Select;

my $game = Chess::Rep->new;
my $bestmove;
my @undolist; # fen

my $state = 'inactive';

my $rank = 0;
my $file = 0;
my $from;
my $move;

my $turn = 1;

my %keymap = (
    14 => 1,
    15 => 2,
    16 => 3,
    17 => 4,
);

$| = 1;

# TODO: require multiple presses to activate in a short time
# TODO: some way to deactivate by multiple presses of 1 in a short time
# TODO: repeat "output_move" if no input within a few seconds?
# TODO: move all this to python so that it is more in sync with the IO? Or at least flush all inputs in input() before waiting to accept any
# TODO: a way to go through the undo list
# TODO: a way to swap sides
# TODO: a way to query the current state?

while (1) {
    my $ch = input();

    if ($state eq 'inactive') {
        if ($ch eq '2') {
            goodinput();
            newgame();
            outputmove(bestmove()) if $turn;
            $rank = 0;
            $file = 0;
            $state = 'getfrom';
        }
    } elsif ($state eq 'getfrom') {
        $file++ if $ch eq '2';
        $rank++ if $ch eq '3';
        if ($ch eq '4') {
            if ($file == 0 && $rank == 0 && $turn) {
                playmove(bestmove());
                goodinput();
                $rank = 0;
                $file = 0;
                $state = 'getfrom';
            } elsif ($file >= 1 && $file <= 8 && $rank >= 1 && $rank <= 8) {
                $from = chr($file + ord('a') - 1) . $rank;
                $rank = 0;
                $file = 0;
                $state = 'getto';
                goodinput();
            } else {
                $rank = 0;
                $file = 0;
                badinput();
                outputmove(bestmove());
            }
        }
        if ($ch eq '1') {
            badinput();
            outputmove(bestmove()) if $turn;
            $file = 0;
            $rank = 0;
        }
    } elsif ($state eq 'getto') {
        $file++ if $ch eq '2';
        $rank++ if $ch eq '3';
        if ($ch eq '4') {
            if ($file >= 1 && $file <= 8 && $rank >= 1 && $rank <= 8) {
                $move = $from . chr($file + ord('a') - 1) . $rank;
                try {
                    playmove($move);
                    goodinput();
                } catch {
                    badinput();
                };
                $rank = 0;
                $file = 0;
                $state = 'getfrom';
                outputmove(bestmove()) if $turn;
            } else {
                $rank = 0;
                $file = 0;
                badinput();
                outputmove(bestmove()) if $turn;
                $state = 'getfrom';
            }
        }
        if ($ch eq '1') {
            $rank = 0;
            $file = 0;
            badinput();
            outputmove(bestmove()) if $turn;
            $state = 'getfrom';
        }
    }
}

sub input {
    # discard any pending input
    my $s = IO::Select->new;
    $s->add(\*STDIN);
    <> while $s->can_read(0.01);

    my $l = <>;
    chomp $l;
    vibrate(50,50);
    return $keymap{$l}||$l;
}

sub outputmove {
    my ($move) = @_;
    my ($fromfile, $fromrank, $tofile, $torank) = split //, $move;
    $fromfile = ord($fromfile) - ord('a') + 1;
    $tofile = ord($tofile) - ord('a') + 1;

    usleep(500_000);

    lvibrate(200,200) for (1 .. $fromfile);
    usleep(200_000);
    rvibrate(200,200) for (1 .. $fromrank);

    return if input() eq '1';

    usleep(500_000);

    lvibrate(200,200) for (1 .. $tofile);
    usleep(200_000);
    rvibrate(200,200) for (1 .. $torank);
}

sub badinput {
    vibrate(500, 100);
    vibrate(100, 100) for (1..3);
}

sub goodinput {
    vibrate(200, 200);
}

# times in ms
sub lvibrate {
    my ($ontime, $offtime) = @_;
    print "l on\n";
    usleep($ontime * 1000);
    print "l off\n";
    usleep($offtime * 1000);
}

# times in ms
sub rvibrate {
    my ($ontime, $offtime) = @_;
    print "r on\n";
    usleep($ontime * 1000);
    print "r off\n";
    usleep($offtime * 1000);
}

# times in ms
sub vibrate {
    my ($ontime, $offtime) = @_;
    print "l on\nr on\n";
    usleep($ontime * 1000);
    print "l off\nr off\n";
    usleep($offtime * 1000);
}

sub newgame {
    $game = Chess::Rep->new;
    $bestmove = undef;
    @undolist = ();
}

sub undo {
    $game = Chess::Rep->new(pop @undolist) if @undolist;
}

sub bestmove {
    $bestmove = compute_bestmove() if !$bestmove;
    return $bestmove;
}

sub compute_bestmove {
    my $fen = $game->get_fen;
    my $move = `./solve $fen`;
    chomp $move;
    return $move;
}

sub playmove {
    my ($move) = @_;

    my $fen= $game->get_fen;

    $game->go_move($move); # dies if move is illegal

    push @undolist, $game->get_fen;
    $turn = !$turn;
    $bestmove = undef;

    print STDERR "PLAY MOVE: $move\n";
}
